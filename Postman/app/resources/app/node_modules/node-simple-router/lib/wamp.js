// Generated by CoffeeScript 1.10.0
(function() {
  var MAX_ID, MESSAGE_TYPES, TRANSPORT_TYPES, WampClient, WampPeer, WampRouter, createWampRouter, defer, e, error, events, genId, isValidURI, net, randomNum, test, util, ws,
    bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  events = require('events');

  util = require('util');

  net = require('net');

  ws = require('./ws');

  defer = require('./promises').defer;

  try {
    defer = require('./promises.litcoffee').defer;
  } catch (error) {
    e = error;
    defer = require('./promises').defer;
  }

  MESSAGE_TYPES = {
    HELLO: 1,
    WELCOME: 2,
    ABORT: 3,
    CHALLENGE: 4,
    AUTHENTICATE: 5,
    GOODBYE: 6,
    HEARTBEAT: 7,
    ERROR: 8,
    PUBLISH: 16,
    PUBLISHED: 17,
    SUBSCRIBE: 32,
    SUBSCRIBED: 33,
    UNSUBSCRIBE: 34,
    UNSUBSCRIBED: 35,
    EVENT: 36,
    CALL: 48,
    CANCEL: 49,
    RESULT: 50,
    REGISTER: 64,
    REGISTERED: 65,
    UNREGISTER: 66,
    UNREGISTERED: 67,
    INVOCATION: 68,
    INTERRUPT: 69,
    YIELD: 70
  };

  TRANSPORT_TYPES = {
    DIRECT: 1,
    WEBSOCKET: 2,
    UNIXSOCKET: 3
  };

  MAX_ID = Math.pow(2, 53);

  isValidURI = function(uri_string) {
    return !!uri_string.match(/^(([0-9a-z_]{2,}\.)|\.)*([0-9a-z_]{2,})?$/);
  };

  randomNum = function(len) {
    var n;
    return parseInt(((function() {
      var i, ref, results;
      results = [];
      for (n = i = 1, ref = len; 1 <= ref ? i <= ref : i >= ref; n = 1 <= ref ? ++i : --i) {
        results.push((Math.floor(Math.random() * 10)).toString());
      }
      return results;
    })()).join(''));
  };

  genId = function() {
    return randomNum(15);
  };


  /*
  class WampSession extends events.EventEmitter
    constructor: (@id, options) ->
      @_options = options or {}
      for key, val of @_options
        @[key] = val
      @nextId = 1
   */

  WampPeer = (function(superClass) {
    "Peer at one end of Wamp Session. Involves acting as a session itself, as well";
    extend(WampPeer, superClass);

    function WampPeer(parent, transport, roles, options) {
      this.parent = parent;
      this.transport = transport;
      this.roles = roles;
      this.processMessage = bind(this.processMessage, this);
      this.sendMessage = bind(this.sendMessage, this);
      this.cleanUp = bind(this.cleanUp, this);
      this.setOptions = bind(this.setOptions, this);
      this.isOpen = true;
      this.transport.on('close', (function(_this) {
        return function(code) {
          _this.isOpen = false;
          _this.cleanUp();
          return console.log("Closing WampPeer due to transport closed.");
        };
      })(this));
      this.id = null;
      this.nextId = 1;
      this.setOptions(options);
    }

    WampPeer.prototype.setOptions = function(options) {
      var key, ref, results, val;
      this._options = options || {};
      ref = this._options;
      results = [];
      for (key in ref) {
        val = ref[key];
        results.push(this[key] = val);
      }
      return results;
    };

    WampPeer.prototype.cleanUp = function() {
      var error1, error2, error3, error4, i, index, invocation, invocations, j, k, key, l, len1, len2, len3, len4, proc, ref, ref1, ref2, ref3, registered, results, session, sessions, subscription, subscriptions, topic;
      registered = (ref = this.parent.realms) != null ? ref[this.realm].registered_procedures : void 0;
      if (registered) {
        for (index = i = 0, len1 = registered.length; i < len1; index = ++i) {
          proc = registered[index];
          try {
            if (proc.sessionId === this.id) {
              this.parent.realms[this.realm].registered_procedures.splice(index, 1);
            }
          } catch (error1) {
            e = error1;
            console.log("ERROR: " + e.message);
          }
        }
      }
      invocations = (ref1 = this.parent.realms) != null ? ref1[this.realm].invocations : void 0;
      if (invocations) {
        for (index = j = 0, len2 = invocations.length; j < len2; index = ++j) {
          invocation = invocations[index];
          try {
            if (invocation.sessionId === this.id) {
              this.parent.realms[this.realm].invocations.splice(index, 1);
            }
          } catch (error2) {
            e = error2;
            console.log("ERROR: " + e.message);
          }
        }
      }
      subscriptions = (ref2 = this.parent.realms) != null ? ref2[this.realm].subscriptions : void 0;
      if (subscriptions) {
        for (key in subscriptions) {
          topic = subscriptions[key];
          try {
            for (index = k = 0, len3 = topic.length; k < len3; index = ++k) {
              subscription = topic[index];
              if (subscription.sessionId === this.id) {
                topic.splice(index, 1);
              }
            }
          } catch (error3) {
            e = error3;
            console.log("ERROR: " + e.message);
          }
        }
      }
      sessions = (ref3 = this.parent.realms) != null ? ref3[this.realm].sessions : void 0;
      if (sessions) {
        results = [];
        for (index = l = 0, len4 = sessions.length; l < len4; index = ++l) {
          session = sessions[index];
          try {
            if (session.id === this.id) {
              this.parent.realms[this.realm].sessions.splice(index, 1);
              break;
            } else {
              results.push(void 0);
            }
          } catch (error4) {
            e = error4;
            results.push(console.log("ERROR: " + e.message));
          }
        }
        return results;
      }
    };

    WampPeer.prototype.sendMessage = function(message) {

      /*
      if @parent.constructor.name is "WampClient"
        console.log @parent.constructor.name, "sends a message:", JSON.stringify(message)
        console.log "Open condition is:", @isOpen
        console.log "WebSocket state is: %s", @transport.readyState
       */
      if (this.isOpen) {
        return this.transport.send(message);
      }
    };

    WampPeer.prototype.processMessage = function(message) {
      var ArgumentsKwDict, ArgumentsList, Details, KwArguments, OptionsDict, ProcedureUri, PublicationId, RegistrationId, RequestId, SubscriptionId, TopicUri, args, arr, base, callee_session, callee_sessionId, caller_session, caller_sessionId, code, details, i, index, invocation, invocation_message, j, k, key, kwArgs, l, len1, len10, len11, len12, len13, len14, len15, len2, len3, len4, len5, len6, len7, len8, len9, m, msgArray, o, p, pendingCall, proc, procedure, publication, q, r, realm, ref, ref1, ref10, ref11, ref12, ref13, ref14, ref15, ref16, ref17, ref18, ref19, ref2, ref20, ref21, ref22, ref23, ref24, ref25, ref26, ref27, ref28, ref29, ref3, ref4, ref5, ref6, ref7, ref8, ref9, registered_procedure, registration, registrationId, resp, result, result_message, results, results1, results2, results3, results4, results5, s, session, sid, subscription, suscription, t, topic, u, v, w, x;
      if (!this.isOpen) {
        return;
      }
      arr = JSON.parse(message);
      code = arr[0];
      if (code !== MESSAGE_TYPES.HELLO && code !== MESSAGE_TYPES.WELCOME) {
        if (!this.id) {
          return;
        }
      }
      switch (code) {
        case MESSAGE_TYPES.HELLO:
          console.log("Router received HELLO message");
          ref = arr.slice(1), realm = ref[0], details = ref[1];
          this.id = this.parent.nextSessionId;
          this.realm = realm;
          this.setOptions(details);
          if (!(realm in this.parent.realms)) {
            this.parent.realms[realm] = {
              sessions: [],
              registered_procedures: [],
              invocations: [],
              subscriptions: {}
            };
          }
          this.parent.realms[realm].sessions.push(this);
          console.log("@realms[" + realm + "].sessions.length: %d", this.parent.realms[realm].sessions.length);
          this.sendMessage(JSON.stringify([
            MESSAGE_TYPES.WELCOME, this.parent.nextSessionId, {
              roles: this.roles
            }
          ]));
          console.log("Router sent WELCOME message to " + this.parent.nextSessionId);
          return this.parent.nextSessionId += 1;
        case MESSAGE_TYPES.WELCOME:
          console.log("Client Received Welcome Message");
          ref1 = arr.slice(1), sid = ref1[0], details = ref1[1];
          this.id = sid;
          this.routerRoles = details;
          this.realm = this.parent.realm;
          this.parent.subscriptions = this.subscriptions = [];
          this.parent.publications = this.publications = [];
          this.parent.registrations = this.registrations = [];
          this.parent.calls = this.calls = [];
          return typeof (base = this.parent).onopen === "function" ? base.onopen({
            id: this.id,
            realm: this.realm,
            roles: this.roles,
            routerRoles: this.routerRoles,
            subscriptions: this.subscriptions,
            registrations: this.registrations,
            calls: this.calls
          }) : void 0;
        case MESSAGE_TYPES.ABORT:
          return console.log("Received Abort Message");
        case MESSAGE_TYPES.CHALLENGE:
          return console.log("Received Challenge Message");
        case MESSAGE_TYPES.AUTHENTICATE:
          return console.log("Received Authenticate Message");
        case MESSAGE_TYPES.GOODBYE:
          console.log("Received GoodBye Message");
          this.sendMessage(message);
          this.cleanUp();
          return this.transport.close();
        case MESSAGE_TYPES.HEARTBEAT:
          return console.log("Received HeartBeat Message");
        case MESSAGE_TYPES.PUBLISH:
          ref2 = arr.slice(1), RequestId = ref2[0], OptionsDict = ref2[1], TopicUri = ref2[2], ArgumentsList = ref2[3], ArgumentsKwDict = ref2[4];
          PublicationId = this.nextId;
          this.nextId += 1;
          topic = this.parent.realms[this.realm].subscriptions[TopicUri];
          if (topic) {
            for (i = 0, len1 = topic.length; i < len1; i++) {
              suscription = topic[i];
              ref3 = this.parent.realms[this.realm].sessions;
              for (j = 0, len2 = ref3.length; j < len2; j++) {
                session = ref3[j];
                if (session.id === suscription.sessionId) {
                  msgArray = [MESSAGE_TYPES.EVENT, suscription.SubscriptionId, PublicationId, OptionsDict];
                  if (ArgumentsList) {
                    msgArray.push(ArgumentsList);
                  }
                  if (ArgumentsKwDict) {
                    msgArray.push(ArgumentsKwDict);
                  }
                  session.sendMessage(JSON.stringify(msgArray));
                  break;
                }
              }
            }
          }
          if (OptionsDict.acknowledge) {
            return this.sendMessage(JSON.stringify([MESSAGE_TYPES.PUBLISHED, RequestId, PublicationId]));
          }
          break;
        case MESSAGE_TYPES.PUBLISHED:
          ref4 = arr.slice(1), RequestId = ref4[0], PublicationId = ref4[1];
          console.log("Received Published Message for Request Id: " + RequestId + " with Publication Id: " + PublicationId);
          ref5 = this.parent.publications;
          results = [];
          for (k = 0, len3 = ref5.length; k < len3; k++) {
            publication = ref5[k];
            if (publication.RequestId === RequestId) {
              publication.PublicatioId = PublicatioId;
              console.log("Updated publication " + RequestId + " with publication id: " + PublicationId);
              break;
            } else {
              results.push(void 0);
            }
          }
          return results;
          break;
        case MESSAGE_TYPES.SUBSCRIBE:
          console.log("Received subscribe message from session " + this.id);
          ref6 = arr.slice(1), RequestId = ref6[0], OptionsDict = ref6[1], TopicUri = ref6[2];
          SubscriptionId = this.nextId;
          this.nextId += 1;
          if (!this.parent.realms[this.realm].subscriptions[TopicUri]) {
            this.parent.realms[this.realm].subscriptions[TopicUri] = [];
          }
          this.parent.realms[this.realm].subscriptions[TopicUri].push({
            sessionId: this.id,
            SubscriptionId: SubscriptionId,
            OptionsDict: OptionsDict
          });
          resp = [MESSAGE_TYPES.SUBSCRIBED, RequestId, SubscriptionId];
          this.sendMessage(JSON.stringify(resp));
          return console.log("Registered subscription for " + TopicUri + " in realm " + this.realm);
        case MESSAGE_TYPES.SUBSCRIBED:
          ref7 = arr.slice(1), RequestId = ref7[0], SubscriptionId = ref7[1];
          console.log("Received Subscribed Message for Request Id: " + RequestId + " with Subscription Id: " + SubscriptionId);
          ref8 = this.parent.subscriptions;
          results1 = [];
          for (l = 0, len4 = ref8.length; l < len4; l++) {
            subscription = ref8[l];
            if (subscription.RequestId === RequestId) {
              subscription.SubscriptionId = SubscriptionId;
              console.log("Updated subscription " + subscription.topic + " with subscription id: " + SubscriptionId);
              break;
            } else {
              results1.push(void 0);
            }
          }
          return results1;
          break;
        case MESSAGE_TYPES.UNSUBSCRIBE:
          ref9 = arr.slice(1), RequestId = ref9[0], SubscriptionId = ref9[1];
          console.log("Received unsubscribe message from session " + this.id + " with requestId: " + RequestId + " and subscriptionId: " + SubscriptionId);
          ref10 = this.parent.realms[this.realm].subscriptions;
          for (key in ref10) {
            topic = ref10[key];
            for (index = m = 0, len5 = topic.length; m < len5; index = ++m) {
              subscription = topic[index];
              if ((subscription.SubscriptionId === SubscriptionId) && (subscription.sessionId === this.id)) {
                console.log("Found subscription to erase at index " + index + ". Going to do it for request: " + RequestId);
                topic.splice(index, 1);
                return this.sendMessage(JSON.stringify([MESSAGE_TYPES.UNSUBSCRIBED, RequestId]));
              }
            }
          }
          console.log("Did not find a subscription to erase. Sending error message: 'wamp.error.no_such_subscription'");
          return this.sendMessage(JSON.stringify([MESSAGE_TYPES.ERROR, MESSAGE_TYPES.UNSUBSCRIBE, RequestId, {}, "wamp.error.no_such_subscription"]));
        case MESSAGE_TYPES.UNSUBSCRIBED:
          return console.log("Received Unsubscribed Message");
        case MESSAGE_TYPES.EVENT:
          ref11 = arr.slice(1), SubscriptionId = ref11[0], PublicationId = ref11[1], Details = ref11[2], args = ref11[3], kwArgs = ref11[4];
          console.log("Received Event Message for subscription id: " + SubscriptionId + " with the following args: %j", args);
          ref12 = this.subscriptions;
          results2 = [];
          for (o = 0, len6 = ref12.length; o < len6; o++) {
            subscription = ref12[o];
            if (subscription.SubscriptionId === SubscriptionId) {
              subscription.handler(args, kwArgs);
              break;
            } else {
              results2.push(void 0);
            }
          }
          return results2;
          break;
        case MESSAGE_TYPES.CALL:
          ref13 = arr.slice(1), RequestId = ref13[0], OptionsDict = ref13[1], ProcedureUri = ref13[2], ArgumentsList = ref13[3], ArgumentsKwDict = ref13[4];
          ref14 = this.parent.realms[this.realm].registered_procedures;
          for (p = 0, len7 = ref14.length; p < len7; p++) {
            proc = ref14[p];
            if (proc.ProcedureUri === ProcedureUri) {
              callee_sessionId = proc.sessionId;
              registrationId = proc.RegistrationId;
              ref15 = this.parent.realms[this.realm].sessions;
              for (q = 0, len8 = ref15.length; q < len8; q++) {
                session = ref15[q];
                if (session.id === callee_sessionId) {
                  callee_session = session;
                  invocation_message = [MESSAGE_TYPES.INVOCATION, RequestId, registrationId, OptionsDict, ArgumentsList || [], ArgumentsKwDict || {}];
                  this.parent.realms[this.realm].invocations.push({
                    sessionId: this.id,
                    requestId: RequestId
                  });
                  return callee_session.sendMessage(JSON.stringify(invocation_message));
                }
              }
            }
          }
          break;
        case MESSAGE_TYPES.CANCEL:
          return console.log("Received Cancel Message");
        case MESSAGE_TYPES.RESULT:
          ref16 = arr.slice(1), RequestId = ref16[0], OptionsDict = ref16[1], ArgumentsList = ref16[2], KwArguments = ref16[3];
          console.log("Client received Result Message for request id: " + RequestId + ". Results are: %j , %j", ArgumentsList, KwArguments);
          ref17 = this.calls;
          results3 = [];
          for (index = r = 0, len9 = ref17.length; r < len9; index = ++r) {
            pendingCall = ref17[index];
            if (pendingCall.RequestId === RequestId) {
              if (Object.keys(KwArguments).length !== 0) {
                ArgumentsList(push(KwArguments));
              }
              if ((ref18 = pendingCall.deferred) != null) {
                ref18.resolve(ArgumentsList);
              }
              this.calls.splice(index, 1);
              break;
            } else {
              results3.push(void 0);
            }
          }
          return results3;
          break;
        case MESSAGE_TYPES.REGISTER:
          console.log("Router received register message from session " + this.id);
          ref19 = arr.slice(1), RequestId = ref19[0], OptionsDict = ref19[1], ProcedureUri = ref19[2];
          ref20 = this.parent.realms[this.realm].registered_procedures;
          for (s = 0, len10 = ref20.length; s < len10; s++) {
            procedure = ref20[s];
            if (procedure.ProcedureUri === ProcedureUri) {
              console.log("ERROR: procedure " + ProcedureUri + " already registered.");
              return this.sendMessage(JSON.stringify([MESSAGE_TYPES.ERROR, MESSAGE_TYPES.REGISTER, RequestId, {}, 'wamp.error.procedure_already_exists']));
            }
          }
          RegistrationId = this.nextId;
          this.nextId += 1;
          this.parent.realms[this.realm].registered_procedures.push({
            sessionId: this.id,
            RegistrationId: RegistrationId,
            OptionsDict: OptionsDict,
            ProcedureUri: ProcedureUri
          });
          resp = [MESSAGE_TYPES.REGISTERED, RequestId, RegistrationId];
          this.sendMessage(JSON.stringify(resp));
          return console.log("Router registered procedure " + ProcedureUri + " in realm " + this.realm);
        case MESSAGE_TYPES.REGISTERED:
          ref21 = arr.slice(1), RequestId = ref21[0], RegistrationId = ref21[1];
          console.log("Client received Registered Message for RequestId: %s - RegistrationId: %s", RequestId, RegistrationId);
          ref22 = this.parent.registrations;
          results4 = [];
          for (t = 0, len11 = ref22.length; t < len11; t++) {
            registered_procedure = ref22[t];
            if (registered_procedure.RequestId === RequestId) {
              registered_procedure.RegistrationId = RegistrationId;
              console.log("Updated registered procedure " + registered_procedure.uri + " with registration id: " + RegistrationId);
              break;
            } else {
              results4.push(void 0);
            }
          }
          return results4;
          break;
        case MESSAGE_TYPES.UNREGISTER:
          console.log("Received Unregister Message");
          ref23 = arr.slice(1), RequestId = ref23[0], RegistrationId = ref23[1];
          ref24 = this.parent.realms[this.realm].registered_procedures;
          for (index = u = 0, len12 = ref24.length; u < len12; index = ++u) {
            procedure = ref24[index];
            if (procedure.RegistrationId === RegistrationId) {
              this.parent.realms[this.realm].registered_procedures.splice(index, 1);
              return this.sendMessage(JSON.stringify([MESSAGE_TYPES.UNREGISTERED, RequestId]));
            }
          }
          return this.sendMessage(JSON.stringify([MESSAGE_TYPES.ERROR, MESSAGE_TYPES.UNREGISTER, RequestId, {}, 'wamp.error.no_such_registration']));
        case MESSAGE_TYPES.UNREGISTERED:
          RequestId = arr.slice(1)[0];
          return console.log("Received Unregistered Message for RequestId: %s", RequestId);
        case MESSAGE_TYPES.INVOCATION:
          ref25 = arr.slice(1), RequestId = ref25[0], RegistrationId = ref25[1], OptionsDict = ref25[2], ArgumentsList = ref25[3], KwArguments = ref25[4];
          console.log("Client received Invocation Message for registration id: " + RegistrationId + " with arguments: %j", ArgumentsList);
          ref26 = this.parent.registrations;
          results5 = [];
          for (index = v = 0, len13 = ref26.length; v < len13; index = ++v) {
            registration = ref26[index];
            if (registration.RegistrationId === RegistrationId) {
              result = registration.fn.apply(null, ArgumentsList, KwArguments);
              this.sendMessage(JSON.stringify([MESSAGE_TYPES.YIELD, RequestId, OptionsDict, [result]]));
              break;
            } else {
              results5.push(void 0);
            }
          }
          return results5;
          break;
        case MESSAGE_TYPES.INTERRUPT:
          return console.log("Client received Interrupt Message");
        case MESSAGE_TYPES.YIELD:
          console.log("Router received Yield Message from session " + this.id);
          ref27 = arr.slice(1), RequestId = ref27[0], OptionsDict = ref27[1], ArgumentsList = ref27[2], ArgumentsKwDict = ref27[3];
          ref28 = this.parent.realms[this.realm].invocations;
          for (w = 0, len14 = ref28.length; w < len14; w++) {
            invocation = ref28[w];
            if (invocation.requestId === RequestId) {
              caller_sessionId = invocation.sessionId;
              ref29 = this.parent.realms[this.realm].sessions;
              for (x = 0, len15 = ref29.length; x < len15; x++) {
                session = ref29[x];
                if (session.id === caller_sessionId) {
                  caller_session = session;
                  result_message = [MESSAGE_TYPES.RESULT, RequestId, OptionsDict, ArgumentsList || [], ArgumentsKwDict || {}];
                  return caller_session.sendMessage(JSON.stringify(result_message));
                }
              }
            }
          }
          break;
        default:
          return console.log("Unknown code received.");
      }
    };

    return WampPeer;

  })(events.EventEmitter);

  WampClient = (function(superClass) {
    extend(WampClient, superClass);

    function WampClient(options) {
      this.publish = bind(this.publish, this);
      this.call = bind(this.call, this);
      this.register = bind(this.register, this);
      this.connect = bind(this.connect, this);
      var key, value;
      if ((!(options != null ? options.url : void 0)) || (!(options != null ? options.realm : void 0))) {
        throw new Error("Must provide a url and a realm to connect to");
      }
      for (key in options) {
        value = options[key];
        this[key] = value;
      }
      this.roles = this.roles || {
        subscriber: {},
        publisher: {},
        callee: {},
        caller: {}
      };
    }

    WampClient.prototype.connect = function() {
      this.websocket = new ws.WebSocketClientConnection(this.url);
      return this.websocket.on('open', (function(_this) {
        return function() {
          _this.peer = new WampPeer(_this, _this.websocket, _this.roles);
          _this.websocket.on('data', function(opcode, data) {
            return _this.peer.processMessage(data);
          });
          _this.peer.sendMessage(JSON.stringify([MESSAGE_TYPES.HELLO, _this.realm, _this.roles]));
          return true;
        };
      })(this));
    };

    WampClient.prototype.register = function(uri, fn, options) {
      var reqId;
      reqId = this.peer.nextId;
      this.peer.nextId += 1;
      this.registrations.push({
        RequestId: reqId,
        uri: uri,
        fn: fn
      });
      return this.peer.sendMessage(JSON.stringify([MESSAGE_TYPES.REGISTER, reqId, options || {}, uri]));
    };

    WampClient.prototype.call = function(procUri, args, kwArgs, options) {
      var callData, deferred, reqId;
      if (args == null) {
        args = [];
      }
      if (kwArgs == null) {
        kwArgs = {};
      }
      if (options == null) {
        options = {};
      }
      reqId = this.peer.nextId;
      this.peer.nextId += 1;
      deferred = defer();
      callData = {
        RequestId: reqId,
        uri: procUri,
        args: args,
        kwArgs: kwArgs,
        options: options,
        deferred: deferred
      };
      this.peer.calls.push(callData);
      this.peer.sendMessage(JSON.stringify([MESSAGE_TYPES.CALL, reqId, options, procUri, args, kwArgs]));
      return deferred.promise();
    };

    WampClient.prototype.subscribe = function(topic, handler, options) {
      var deferred, reqId, subscriptionData;
      if (options == null) {
        options = {};
      }
      reqId = this.peer.nextId;
      this.peer.nextId += 1;
      deferred = defer();
      subscriptionData = {
        RequestId: reqId,
        topic: topic,
        handler: handler,
        options: options,
        deferred: deferred
      };
      this.peer.subscriptions.push(subscriptionData);
      this.peer.sendMessage(JSON.stringify([MESSAGE_TYPES.SUBSCRIBE, reqId, options, topic]));
      return deferred.promise();
    };

    WampClient.prototype.publish = function(topic, args, kwArgs, options) {
      var deferred, publicationData, reqId;
      if (args == null) {
        args = [];
      }
      if (kwArgs == null) {
        kwArgs = {};
      }
      if (options == null) {
        options = {};
      }
      reqId = this.peer.nextId;
      this.peer.nextId += 1;
      deferred = defer();
      publicationData = {
        RequestId: reqId,
        topic: topic,
        args: args,
        kwArgs: kwArgs,
        options: options,
        deferred: deferred
      };
      this.peer.publications.push(publicationData);
      this.peer.sendMessage(JSON.stringify([MESSAGE_TYPES.PUBLISH, reqId, options, topic, args, kwArgs]));
      return deferred.promise();
    };

    return WampClient;

  })(events.EventEmitter);

  WampRouter = (function(superClass) {
    extend(WampRouter, superClass);

    WampRouter.prototype._webSocketHandler = function(websocket) {
      websocket.peer = new WampPeer(this, websocket, this.roles);
      websocket.on('open', (function(_this) {
        return function() {
          return console.log("WebSocket opened");
        };
      })(this));
      websocket.on('data', (function(_this) {
        return function(opcode, data) {
          return websocket.peer.processMessage(data);
        };
      })(this));
      return websocket.on('close', (function(_this) {
        return function(code, reason) {
          return console.log("Websocket closed. Close event data:\n Code: " + (code || 'no data') + " - Reason: " + (reason || 'no data'));
        };
      })(this));
    };

    function WampRouter(options) {
      this.listen = bind(this.listen, this);
      this._webSocketHandler = bind(this._webSocketHandler, this);
      this._options = options || {};
      this.roles = this._options.roles || {
        broker: {},
        dealer: {}
      };
      this.nextSessionId = genId();
      this.realms = {};
      this.webSocketServer = ws.createWebSocketServer(this._webSocketHandler);
    }

    WampRouter.prototype.listen = function(port, host, route) {
      if (host == null) {
        host = '0.0.0.0';
      }
      if (route == null) {
        route = '/wamp';
      }
      return this.webSocketServer.listen(port, host, route);
    };

    return WampRouter;

  })(events.EventEmitter);

  createWampRouter = function() {
    return new WampRouter;
  };

  test = function() {
    var wampRouter;
    wampRouter = createWampRouter();
    wampRouter.listen(8000, '0.0.0.0', '/');
    return console.log("WAMP Router listening on port 8000");
  };

  if (typeof module !== "undefined" && module !== null) {
    module.exports = {
      MESSAGE_TYPES: MESSAGE_TYPES,
      TRANSPORT_TYPES: TRANSPORT_TYPES,
      WampPeer: WampPeer,
      WampClient: WampClient,
      WampRouter: WampRouter,
      createWampRouter: createWampRouter
    };
  }

  if (!(typeof module !== "undefined" && module !== null ? module.parent : void 0)) {
    test();
  }

}).call(this);
